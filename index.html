<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ðŸŽ¨ Telestrations Game ðŸŽ¨</title>
<style>
  body { font-family: Arial, sans-serif; background-color: #e6f3ff; text-align: center; margin: 0; padding: 0; color:#123; }
  h1 { color: #0b66b2; margin: 18px 0 8px; cursor:pointer; }
  .container { max-width: 900px; margin: 12px auto; background: white; padding: 18px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.08); position: relative; }
  button { background-color: #007bff; color: white; border: none; padding: 10px 14px; border-radius: 8px; cursor: pointer; }
  button:hover { background-color: #0056b3; }
  input { padding: 8px; margin: 5px; width: 80%; border-radius: 8px; border: 1px solid #cbd6e2; }
  canvas { border: 2px solid #007bff; border-radius: 10px; margin-top: 10px; background: white; touch-action: none; max-width: 100%; }
  .hidden { display: none; }
  ul { list-style: none; padding: 0; }
  .muted { color:#517089; font-size:14px; }

  #roomBanner { display:none; background:#d9ecff; border-top:1px solid #c4e1ff; border-bottom:1px solid #c4e1ff; padding:8px 0; font-weight:700; color:#0b66b2; }

  .turnOrderBox {
    display:none; max-width:600px; margin:15px auto 0 auto;
    background:#f7fbff; border:1px solid #c4e1ff; border-radius:10px; padding:10px; text-align:left;
  }
  .turnOrderBox h4 { margin:0 0 6px; color:#0b66b2; }
  .turnOrderList { padding:0; margin:0; }
  .turnOrderList li { list-style:none; padding:3px 0; font-size:15px; }
  .turnOrderList li.current::before { content:"â†’ "; color:#0b66b2; font-weight:700; }

  .activePen { background-color:#28a745 !important; }

  /* Desktop-only: make username box shorter; mobile keeps wide */
  @media (min-width: 768px) {
    #usernameInput { width: 40%; }
  }

  /* Instruction panel */
  .infoPanel {
    margin-top: 12px; padding:10px; border-radius:10px;
    background:#eaf5ff; border:1px solid #cfe6ff; color:#0b3f6b; text-align:left;
  }
  .infoPanel ul { margin:0; padding-left:18px; }
  .infoPanel li { margin:4px 0; list-style: disc; }
</style>
</head>
<body>
  <h1 onclick="resetToHome()">ðŸŽ¨ Telestrations Game ðŸŽ¨</h1>
  <div id="roomBanner">Room Code: <span id="bannerCode"></span></div>

  <!-- HOME -->
  <div class="container" id="homeScreen">
    <h3>Enter a username:</h3>
    <input type="text" id="usernameInput" placeholder="Your username" maxlength="25"><br><br>
    <button onclick="createRoom()">Create Room</button>
    <button onclick="joinRoomPrompt()">Join Room</button>

    <!-- concise instructions -->
    <div class="infoPanel">
      <ul>
        <li>Host creates a room and picks the first word/phrase.</li>
        <li>Turns alternate: draw (60s) â†’ guess (30s).</li>
        <li>Submit anytime; timer auto-submits when it ends.</li>
        <li>See the chain at the end. Have fun!</li>
      </ul>
    </div>
  </div>

  <!-- LOBBY -->
  <div class="container hidden" id="lobbyScreen">
    <h2>Room Code: <span id="roomCodeDisplay"></span></h2>
    <ul id="playerList"></ul>
    <p class="muted" id="lobbyMsg"></p>
    <button id="startGameBtn" class="hidden" onclick="startGame()">Start Game</button>

    <!-- concise instructions duplicate -->
    <div class="infoPanel">
      <ul>
        <li>Host starts once everyone joins (2â€“15 players).</li>
        <li>Turns alternate: draw (60s) â†’ guess (30s).</li>
        <li>Submit anytime; timer auto-submits when it ends.</li>
        <li>Results reveal the full chain.</li>
      </ul>
    </div>

    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- WORD SELECT -->
  <div class="container hidden" id="wordSelectScreen">
    <h3>Pick a Word or Phrase</h3>
    <input type="text" id="customWord" placeholder="Enter custom word/phrase"><br><br>
    <button onclick="suggestWord()">Suggest Word</button>
    <p id="suggestedWord" style="font-weight:700;color:#0b66b2"></p>
    <button onclick="confirmWord()">Confirm & Start Round</button>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- DRAW -->
  <div class="container hidden" id="drawingScreen">
    <h3 id="drawPrompt"></h3>
    <canvas id="drawCanvas" width="720" height="460"></canvas><br>
    <div>
      <button id="smallPen" onclick="setPenSize(2)">Small</button>
      <button id="mediumPen" onclick="setPenSize(6)">Medium</button>
      <button id="largePen" onclick="setPenSize(12)">Large</button>
    </div>
    <div style="margin-top:8px;">
      <button onclick="undo()">Undo</button>
      <button onclick="clearCanvas()">Clear</button>
      <span class="timer" id="drawTimer">60s</span>
      <button onclick="submitDrawing(false)">Submit Drawing</button>
    </div>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- GUESS (inputs ABOVE image now) -->
  <div class="container hidden" id="guessScreen">
    <h3>Guess the drawing!</h3>
    <div style="margin-top:10px;">
      <input id="guessInput" type="text" placeholder="Type your guess here" />
    </div>
    <div style="margin-top:8px;">
      <span class="timer" id="guessTimer">30s</span>
      <button onclick="submitGuess()">Submit Guess</button>
    </div>
    <img id="guessImage" style="max-width:100%;border:1px solid #ddd;border-radius:8px;margin-top:10px;" />
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- WAIT -->
  <div class="container hidden" id="waitScreen">
    <p id="waitMsg">Waitingâ€¦</p>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- RESULTS -->
  <div class="container hidden" id="resultsScreen">
    <h2>Results Summary</h2>
    <div style="font-weight:700;color:#0b66b2">Original: <span id="finalWord"></span></div>
    <div id="resultsList" style="text-align:left;margin-top:12px;"></div>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
  /* ---------- FIREBASE ---------- */
  const firebaseConfig = {
    apiKey: "AIzaSyD6LY0o8SfAqX08h3tuLheGJQ9YOm1IKE0",
    authDomain: "telestrations-game-aa386.firebaseapp.com",
    databaseURL: "https://telestrations-game-aa386-default-rtdb.firebaseio.com/",
    projectId: "telestrations-game-aa386",
    storageBucket: "telestrations-game-aa386.firebasestorage.app",
    messagingSenderId: "461499249155",
    appId: "1:461499249155:web:c785ab9cd1c7aab44f1436"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /* ---------- STATE ---------- */
  let username="", roomCode="", isHost=false, penSize=6;
  let drawInterval=null, guessInterval=null, turnTicker=null;

  /* ---------- WORD LIST (sample) ---------- */
  const phrases = [
    "Awkward handshake","Surfing grandma","Invisible dog","Couch potato","Dancing with wolves",
    "Robot yoga","Time capsule","Elephant on a skateboard","Synchronized napping","Haunted smartphone",
    "Window-shopping dinosaur","Broken umbrella parade","Flying carpet commute","Secret admirer note",
    "Lost astronaut","Backwards clock","Talking mailbox","Walking on eggshells","Tickled pink",
    "Rocket-powered shoes","Barking up the wrong tree","Two peas in a pod","Fish out of water"
  ];

  /* ---------- UTIL ---------- */
  const byId = id => document.getElementById(id);
  function showOnly(id){
    ["homeScreen","lobbyScreen","wordSelectScreen","drawingScreen","guessScreen","waitScreen","resultsScreen"]
      .forEach(el=>byId(el).classList.add("hidden"));
    byId(id).classList.remove("hidden");
  }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
  function setBanner(code){ byId('bannerCode').textContent = code; byId('roomBanner').style.display='block'; }
  function resetToHome(){ location.reload(); }

  /* ---------- CREATE / JOIN ---------- */
  function createRoom(){
    username = byId('usernameInput').value.trim();
    if(!username) return alert("Enter a username first");
    isHost = true;
    roomCode = Math.random().toString(36).substring(2,6).toUpperCase();
    setBanner(roomCode);
    db.ref('rooms/'+roomCode).set({
      host: username, players: [username], state:'lobby',
      order: null, currentIndex: 0, gameData:{}, word:null,
      turnStart: null
    });
    subscribeRoom();
    showLobby();
  }

  function joinRoomPrompt(){
    username = byId('usernameInput').value.trim();
    if(!username) return alert("Enter a username first");
    const code = prompt("Enter Room Code (not case-sensitive):");
    if(!code) return;
    roomCode = code.toUpperCase();
    setBanner(roomCode);

    const roomRef = db.ref('rooms/'+roomCode);
    roomRef.once('value').then(s=>{
      if(!s.exists()){ alert("Room not found"); return; }
      const r = s.val();
      const players = r.players || [];
      if(!players.includes(username)) players.push(username);
      return roomRef.child('players').set(players);
    }).then(()=>{
      isHost = false;
      subscribeRoom();
      showLobby();
    });
  }

  /* ---------- LOBBY ---------- */
  function showLobby(){
    showOnly('lobbyScreen');
    byId('roomCodeDisplay').innerText = roomCode;
    const listEl = byId('playerList');

    db.ref('rooms/'+roomCode+'/players').on('value', snap=>{
      const list = snap.val() || [];
      listEl.innerHTML = list.map(p=>`<li>${p}</li>`).join("");
      const canStart = isHost && list.length >= 2 && list.length <= 15;
      byId('startGameBtn').classList.toggle('hidden', !canStart);
      byId('lobbyMsg').innerText = isHost
        ? "A minimum of 2 players are needed to start, and you can have up to 15 total."
        : "Waiting for the host to start the game once everyone has joined and is ready.";
    });
  }

  function startGame(){
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const players = room.players || [];
      const host = players[0];
      const others = shuffle(players.slice(1)); // randomize everyone except host
      const order = [host, ...others];
      db.ref('rooms/'+roomCode).update({ order, currentIndex: 0, state: 'wordSelect', turnStart: null });
    });
  }

  /* ---------- WORD PICK ---------- */
  function suggestWord(){
    byId('suggestedWord').innerText = phrases[Math.floor(Math.random()*phrases.length)];
  }
  function confirmWord(){
    const c = byId('customWord').value.trim();
    const w = c || byId('suggestedWord').innerText;
    if(!w) return alert("Pick or enter a word/phrase first");
    // set drawing phase + timestamp so all clients can compute remaining time
    db.ref('rooms/'+roomCode).update({ word: w, state: 'drawing', currentIndex: 0, turnStart: Date.now() });
  }

  /* ---------- ROOM SUBSCRIBE / STATE MACHINE ---------- */
  let roomListenerAttached = false;
  function subscribeRoom(){
    if(roomListenerAttached) return;
    roomListenerAttached = true;

    db.ref('rooms/'+roomCode).on('value', snapshot=>{
      const room = snapshot.val();
      if(!room){ alert("Room closed"); location.reload(); return; }

      renderTurnOrder(room); // also shows the shared countdown

      if(room.state === 'lobby'){ showLobby(); return; }

      if(room.state === 'wordSelect'){
        if(isHost) showOnly('wordSelectScreen');
        else { byId('waitMsg').innerText = "Host is choosing a wordâ€¦"; showOnly('waitScreen'); }
        stopSharedTurnTicker();
        return;
      }

      const order = room.order || [];
      const idx = room.currentIndex || 0;
      const current = order[idx] || "";
      const myTurn = (current === username);

      // start/refresh shared turn ticker on every state change
      startSharedTurnTicker(room);

      if(room.state === 'drawing'){
        if(myTurn) startDrawingPhase(room, idx);
        else { byId('waitMsg').innerText = `${current} is drawingâ€¦`; showOnly('waitScreen'); }
        return;
      }

      if(room.state === 'guessing'){
        if(myTurn) startGuessingPhase(room, idx);
        else { byId('waitMsg').innerText = `${current} is guessingâ€¦`; showOnly('waitScreen'); }
        return;
      }

      if(room.state === 'results'){
        stopSharedTurnTicker();
        showResults(room);
        return;
      }
    });
  }

  /* ---------- SHARED TURN COUNTDOWN (for Turn Order box) ---------- */
  function startSharedTurnTicker(room){
    stopSharedTurnTicker();
    updateTurnTimerLabels(room); // immediate
    turnTicker = setInterval(()=>{
      updateTurnTimerLabels(room);
    }, 1000);
  }
  function stopSharedTurnTicker(){
    if(turnTicker){ clearInterval(turnTicker); turnTicker = null; }
  }
  function getPhaseDuration(state){
    return state==='drawing' ? 60 : state==='guessing' ? 30 : 0;
  }
  function computeRemaining(room){
    const ts = room.turnStart || 0;
    const dur = getPhaseDuration(room.state);
    if(!ts || !dur) return null;
    const elapsed = Math.floor((Date.now() - ts)/1000);
    const remaining = Math.max(0, dur - elapsed);
    return remaining;
  }
  function updateTurnTimerLabels(room){
    const lists = document.querySelectorAll('.turnOrderList');
    const order = room.order || [];
    const idx = room.currentIndex || 0;
    const remaining = computeRemaining(room);
    lists.forEach(list=>{
      // rewrite with timer next to current player
      list.innerHTML = '';
      order.forEach((name,i)=>{
        const li = document.createElement('li');
        li.textContent = (i===idx && remaining!=null) ? `${name} (${remaining}s)` : name;
        if(i===idx) li.classList.add('current');
        list.appendChild(li);
      });
    });
  }

  /* ---------- TURN ORDER RENDER (visibility toggle) ---------- */
  function renderTurnOrder(room){
    const boxes = document.querySelectorAll('.turnOrderBox');
    const show = (room.order || []).length > 0 && room.state !== 'lobby';
    boxes.forEach(b => b.style.display = show ? 'block' : 'none');
  }

  /* ---------- DRAWING (mobile align + undo pen-size preservation) ---------- */
  const canvas = byId('drawCanvas');
  const ctx = canvas.getContext('2d');

  function resetCanvasBackground(){
    ctx.fillStyle = "white";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }
  resetCanvasBackground();

  let drawing=false;
  // Store each stroke with its own size and points
  let strokes=[]; // [{ size: number, points: [{x,y},...] }, ...]
  let currentStroke=null;

  function highlightPen(btnId){
    ['smallPen','mediumPen','largePen'].forEach(id=>byId(id).classList.remove('activePen'));
    byId(btnId).classList.add('activePen');
  }
  function setPenSize(size){ penSize=size; highlightPen(size===2?'smallPen':size===6?'mediumPen':'largePen'); }
  setPenSize(6);

  // Scale-aware position calculation for mobile & desktop
  function getCanvasPos(e){
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width  / r.width;
    const scaleY = canvas.height / r.height;
    let clientX, clientY;

    if (e.touches && e.touches.length){
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = (e.clientX !== undefined) ? e.clientX : (e.x || 0);
      clientY = (e.clientY !== undefined) ? e.clientY : (e.y || 0);
    }

    const x = (clientX - r.left) * scaleX;
    const y = (clientY - r.top)  * scaleY;
    return { x, y };
  }

  function beginStroke(e){
    drawing = true;
    currentStroke = { size: penSize, points: [] };
    addPoint(e);
  }
  function moveStroke(e){
    if(!drawing) return;
    addPoint(e);
  }
  function endStroke(){
    if(!drawing) return;
    drawing = false;
    if(currentStroke && currentStroke.points.length){
      strokes.push(currentStroke);
    }
    currentStroke = null;
    ctx.beginPath();
  }

  function addPoint(e){
    const p = getCanvasPos(e);
    currentStroke.points.push(p);

    ctx.lineWidth = currentStroke.size; // use stroke's own size
    ctx.lineCap = "round";
    ctx.strokeStyle = "black";

    const pts = currentStroke.points;
    if(pts.length === 1){
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
    }else{
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    }
  }

  // Mouse events
  canvas.addEventListener('mousedown', beginStroke);
  canvas.addEventListener('mousemove', moveStroke);
  canvas.addEventListener('mouseup', endStroke);
  canvas.addEventListener('mouseleave', endStroke);
  // Touch events
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); beginStroke(e); }, {passive:false});
  canvas.addEventListener('touchmove',  e=>{ e.preventDefault(); moveStroke(e);  }, {passive:false});
  canvas.addEventListener('touchend',   e=>{ e.preventDefault(); endStroke();     }, {passive:false});

  function undo(){
    strokes.pop();
    redrawAll();
  }
  function clearCanvas(){
    strokes = [];
    ctx.clearRect(0,0,canvas.width,canvas.height);
    resetCanvasBackground();
  }
  function redrawAll(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    resetCanvasBackground();
    for(const s of strokes){
      const pts = s.points;
      if(!pts.length) continue;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++){
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.lineWidth = s.size;          // preserve original size per stroke
      ctx.strokeStyle = "black";
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }

  function startDrawingPhase(room, idx){
    showOnly('drawingScreen');
    clearCanvas();
    setPenSize(6);
    byId('drawPrompt').innerText = (idx===0)
      ? `Draw the word/phrase: "${room.word}"`
      : `Draw this phrase: "${room.gameData[idx-1].data}"`;
    startDrawTimer();
  }

  // forced=false when user clicks submit; forced=true when timer expires
  function submitDrawing(forced){
    stopDrawTimer();
    if(!forced && strokes.length===0){
      // guard: require at least one stroke on manual submit
      alert("Please add at least one stroke before submitting.");
      startDrawTimer(); // resume timer to let them keep drawing
      return;
    }
    const dataURL = canvas.toDataURL('image/png');
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const idx = room.currentIndex || 0;
      const u = {};
      u['rooms/'+roomCode+'/gameData/'+idx] = { type:'draw', data:dataURL, player:username };
      const next = idx + 1;
      if(next >= (room.order||[]).length){
        u['rooms/'+roomCode+'/state'] = 'results';
      } else {
        u['rooms/'+roomCode+'/currentIndex'] = next;
        u['rooms/'+roomCode+'/state'] = 'guessing';
        u['rooms/'+roomCode+'/turnStart'] = Date.now(); // start guess phase timer for everyone
      }
      db.ref().update(u);
    });
  }

  function startDrawTimer(){
    let t = 60;
    byId('drawTimer').innerText = t + 's';
    drawInterval = setInterval(()=>{
      t--; byId('drawTimer').innerText = t + 's';
      if(t<=0) submitDrawing(true);
    },1000);
  }
  function stopDrawTimer(){ if(drawInterval){ clearInterval(drawInterval); drawInterval=null; byId('drawTimer').innerText='60s'; } }

  /* ---------- GUESSING ---------- */
  function startGuessingPhase(room, idx){
    showOnly('guessScreen');
    const prev = room.gameData[idx-1];
    byId('guessImage').src = prev?.data || '';
    byId('guessInput').value = '';
    startGuessTimer();
  }

  function submitGuess(){
    stopGuessTimer();
    const g = (byId('guessInput').value || '').trim() || 'No guess';
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const idx = room.currentIndex || 0;
      const u = {};
      u['rooms/'+roomCode+'/gameData/'+idx] = { type:'guess', data:g, player:username };
      const next = idx + 1;
      if(next >= (room.order||[]).length){
        u['rooms/'+roomCode+'/state'] = 'results';
      } else {
        u['rooms/'+roomCode+'/currentIndex'] = next;
        u['rooms/'+roomCode+'/state'] = 'drawing';
        u['rooms/'+roomCode+'/turnStart'] = Date.now(); // start draw phase timer for everyone
      }
      db.ref().update(u);
    });
  }

  function startGuessTimer(){
    let t = 30;
    byId('guessTimer').innerText = t + 's';
    guessInterval = setInterval(()=>{
      t--; byId('guessTimer').innerText = t + 's';
      if(t<=0) submitGuess();
    },1000);
  }
  function stopGuessTimer(){ if(guessInterval){ clearInterval(guessInterval); guessInterval=null; byId('guessTimer').innerText='30s'; } }

  /* ---------- RESULTS ---------- */
  function showResults(room){
    showOnly('resultsScreen');
    byId('finalWord').innerText = room.word || '';
    const list = byId('resultsList');
    list.innerHTML = '';
    const steps = Object.keys(room.gameData||{}).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
    steps.forEach(step=>{
      const e = room.gameData[step];
      const div = document.createElement('div');
      div.style.marginBottom = '14px';
      div.innerHTML = `<b>Step ${step+1} â€” ${e.player} (${e.type})</b><br>`;
      if(e.type === 'draw'){
        const img = document.createElement('img');
        img.src = e.data;
        img.style.maxWidth='100%'; img.style.border='1px solid #ddd'; img.style.borderRadius='8px';
        div.appendChild(img);
      } else {
        const p = document.createElement('div');
        p.textContent = e.data; p.style.marginTop='6px';
        div.appendChild(p);
      }
      list.appendChild(div);
    });
  }
  </script>
</body>
</html>
