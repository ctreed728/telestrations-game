<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>üé® Telestrations Game üé®</title>
<style>
  body { font-family: Arial, sans-serif; background-color: #e6f3ff; text-align: center; margin: 0; padding: 0; color:#123; }
  h1 { color: #0b66b2; margin: 18px 0 8px; cursor:pointer; }
  .container { max-width: 900px; margin: 12px auto; background: white; padding: 18px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.08); position: relative; }
  button { background-color: #007bff; color: white; border: none; padding: 10px 14px; border-radius: 8px; cursor: pointer; }
  button:hover { background-color: #0056b3; }
  input { padding: 8px; margin: 5px; width: 80%; border-radius: 8px; border: 1px solid #cbd6e2; }
  canvas { border: 2px solid #007bff; border-radius: 10px; margin-top: 10px; background: white; touch-action: none; max-width: 100%; }
  .hidden { display: none; }
  ul { list-style: none; padding: 0; }
  .muted { color:#517089; font-size:14px; }

  /* Room code banner */
  #roomBanner { display:none; background:#d9ecff; border-top:1px solid #c4e1ff; border-bottom:1px solid #c4e1ff; padding:8px 0; font-weight:700; color:#0b66b2; }

  /* Turn order box */
  .turnOrderBox {
    display:none; max-width:600px; margin:15px auto 0 auto;
    background:#f7fbff; border:1px solid #c4e1ff; border-radius:10px; padding:10px; text-align:left;
  }
  .turnOrderBox h4 { margin:0 0 6px; color:#0b66b2; }
  .turnOrderList { padding:0; margin:0; }
  .turnOrderList li { list-style:none; padding:3px 0; font-size:15px; }
  .turnOrderList li.current::before { content:"‚Üí "; color:#0b66b2; font-weight:700; }

  /* Pen selection highlight */
  .activePen { background-color:#28a745 !important; }

  /* Disconnected styling */
  .disconnected { color:#9aa7b4; opacity:0.7; }

  /* Desktop tweaks */
  @media (min-width: 768px) {
    #usernameInput { width: 40%; }
    .infoPanel { width: 60%; margin: 0 auto; }
    #guessInput { width: 50%; }
  }

  /* Instruction panel */
  .infoPanel {
    margin-top: 12px; padding:10px; border-radius:10px;
    background:#eaf5ff; border:1px solid #cfe6ff; color:#0b3f6b; text-align:left;
  }
  .infoPanel h4 { margin:0 0 6px; color:#0b66b2; text-align:center; }
  .infoPanel ul { margin:0; padding-left:18px; }
  .infoPanel li { margin:4px 0; list-style: disc; }

  /* Results restart box */
  #restartBox {
    margin-top: 20px; background:#eaf5ff; border:1px solid #cfe6ff; border-radius:10px;
    padding:15px; max-width:500px; margin-left:auto; margin-right:auto;
  }

  /* Mobile two-row drawing controls */
  @media (max-width: 767px) {
    #drawControlsTop, #drawControlsBottom { display:flex; justify-content:center; flex-wrap:wrap; gap:6px; }
  }
</style>
</head>
<body>
  <h1 onclick="resetToHome()">üé® Telestrations Game üé®</h1>
  <div id="roomBanner">Room Code: <span id="bannerCode"></span></div>

  <!-- HOME -->
  <div class="container" id="homeScreen">
    <h3>Enter a username:</h3>
    <input type="text" id="usernameInput" placeholder="Your username" maxlength="25"><br><br>
    <button onclick="createRoom()">Create Room</button>
    <button onclick="joinRoomPrompt()">Join Room</button>

    <div class="infoPanel">
      <h4>Here's how the game works:</h4>
      <ul>
        <li>Host creates a room and picks the first word/phrase.</li>
        <li>Turns alternate: draw (60s) ‚Üí guess (30s).</li>
        <li>Submit anytime; timer auto-submits when it ends.</li>
        <li>See the full chain at the end!</li>
      </ul>
    </div>
  </div>

  <!-- LOBBY -->
  <div class="container hidden" id="lobbyScreen">
    <h2>Room Code: <span id="roomCodeDisplay"></span></h2>
    <ul id="playerList"></ul>
    <p class="muted" id="lobbyMsg"></p>
    <button id="startGameBtn" class="hidden" onclick="startGame()">Start Game</button>

    <div class="infoPanel">
      <h4>Here's how the game works:</h4>
      <ul>
        <li>Host starts once everyone joins (2‚Äì15 players).</li>
        <li>Turns alternate: draw (60s) ‚Üí guess (30s).</li>
        <li>Submit anytime; timer auto-submits when it ends.</li>
        <li>See the full chain at the end!</li>
      </ul>
    </div>

    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- WORD SELECT -->
  <div class="container hidden" id="wordSelectScreen">
    <h3>Pick a Word or Phrase</h3>
    <input type="text" id="customWord" placeholder="Enter custom word/phrase"><br><br>
    <button onclick="suggestWord()">Suggest Word</button>
    <p id="suggestedWord" style="font-weight:700;color:#0b66b2"></p>
    <button onclick="confirmWord()">Confirm & Start Round</button>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- DRAW -->
  <div class="container hidden" id="drawingScreen">
    <h3 id="drawPrompt"></h3>
    <div id="drawControlsTop">
      <button id="smallPen" onclick="setPenSize(2)">Small</button>
      <button id="mediumPen" onclick="setPenSize(6)">Medium</button>
      <button id="largePen" onclick="setPenSize(12)">Large</button>
    </div>
    <div id="drawControlsBottom" style="margin-top:8px;">
      <button onclick="undo()">Undo</button>
      <button onclick="clearCanvas()">Clear</button>
      <span class="timer" id="drawTimer">60s</span>
      <button onclick="submitDrawing(false)">Submit Drawing</button>
    </div>
    <canvas id="drawCanvas" width="720" height="460"></canvas>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- GUESS -->
  <div class="container hidden" id="guessScreen">
    <h3>Guess the drawing!</h3>
    <input id="guessInput" type="text" placeholder="Type your guess here" />
    <div style="margin-top:8px;">
      <span class="timer" id="guessTimer">30s</span>
      <button onclick="submitGuess()">Submit Guess</button>
    </div>
    <img id="guessImage" style="max-width:100%;border:1px solid #ddd;border-radius:8px;margin-top:10px;" />
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- WAIT -->
  <div class="container hidden" id="waitScreen">
    <p id="waitMsg">Waiting‚Ä¶</p>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- RESULTS -->
  <div class="container hidden" id="resultsScreen">
    <h2 style="font-size:1.6em;color:#0b66b2;">Results Summary</h2>
    <div style="font-weight:700;color:#0b66b2;font-size:1.25em;">Original Word/Phrase: <span id="finalWord"></span></div>
    <div id="resultsList" style="text-align:left;margin-top:12px;"></div>

    <div id="restartBox">
      <p><b>Ready for another round?</b><br>
      Restart with the same players and shuffle everyone (including the host).</p>
      <button onclick="restartGame()">üîÅ Restart Game</button>
    </div>
  </div>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
  /* ---------- FIREBASE ---------- */
  const firebaseConfig = {
    apiKey: "AIzaSyD6LY0o8SfAqX08h3tuLheGJQ9YOm1IKE0",
    authDomain: "telestrations-game-aa386.firebaseapp.com",
    databaseURL: "https://telestrations-game-aa386-default-rtdb.firebaseio.com/",
    projectId: "telestrations-game-aa386",
    storageBucket: "telestrations-game-aa386.firebasestorage.app",
    messagingSenderId: "461499249155",
    appId: "1:461499249155:web:c785ab9cd1c7aab44f1436"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /* ---------- STATE ---------- */
  let username="", roomCode="", isHost=false, penSize=6;
  let drawInterval=null, guessInterval=null, turnTicker=null;

  /* ---------- WORD LIST (expanded) ---------- */
  const phrases = [
    "Barking up the wrong tree","Surfing grandma","Invisible dog","Couch potato","Dancing with wolves",
    "Robot yoga","Haunted smartphone","Fish out of water","Jumping the gun","Raining cats and dogs",
    "Time traveler","Elephant on a skateboard","Flying carpet commute","Secret admirer note",
    "Backwards clock","Talking mailbox","Walking on eggshells","Tickled pink","Elephant in the room",
    "Rocket-powered shoes","Bulls in a china shop","Two peas in a pod","All ears","Cold feet",
    "Counting sheep","Cat got your tongue","Piece of cake","Hold your horses","Spill the beans",
    "Pigs might fly","Monkey business","Let the cat out of the bag","Crocodile tears","Once in a blue moon",
    "Through the grapevine","Burning the midnight oil","Under the weather","Kick the bucket",
    "Hit the hay","Break a leg","Bite the bullet","When pigs fly","Bend over backwards","Go the extra mile",
    "Skeleton in the closet","Ballpark figure","Birds of a feather","A blessing in disguise",
    "Cut to the chase","The last straw","Take with a grain of salt","On thin ice","Go with the flow",
    "Caught red-handed","Out of the blue","Head in the clouds","The early bird","No stone unturned",
    "Out of left field","Throw in the towel","Up in the air","Silver lining","Burning bridges",
    "In hot water","By the skin of your teeth"
  ];

  /* ---------- UTIL ---------- */
  const byId = id => document.getElementById(id);
  function showOnly(id){
    ["homeScreen","lobbyScreen","wordSelectScreen","drawingScreen","guessScreen","waitScreen","resultsScreen"]
      .forEach(el=>byId(el).classList.add("hidden"));
    byId(id).classList.remove("hidden");
  }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
  function setBanner(code){ byId('bannerCode').textContent = code; byId('roomBanner').style.display='block'; }
  function resetToHome(){ location.reload(); }

  /* ---------- PRESENCE (NEW) ---------- */
  function setupPresence(){
    if(!roomCode || !username) return;
    const connRef = db.ref(`rooms/${roomCode}/connections/${username}`);
    connRef.set(true);
    connRef.onDisconnect().remove();
  }

  /* ---------- CREATE / JOIN ---------- */
  function createRoom(){
    username = byId('usernameInput').value.trim();
    if(!username) return alert("Enter a username first");
    isHost = true;
    roomCode = Math.random().toString(36).substring(2,6).toUpperCase();
    setBanner(roomCode);
    db.ref('rooms/'+roomCode).set({
      host: username, players: [username], state:'lobby',
      order: null, currentIndex: 0, gameData:{}, word:null, turnStart:null,
      connections: {} // NEW: presence map
    }).then(()=>{
      setupPresence();
      subscribeRoom();
      showLobby();
    });
  }

  function joinRoomPrompt(){
    username = byId('usernameInput').value.trim();
    if(!username) return alert("Enter a username first");
    const code = prompt("Enter Room Code (not case-sensitive):");
    if(!code) return;
    roomCode = code.toUpperCase();
    setBanner(roomCode);

    const roomRef = db.ref('rooms/'+roomCode);
    roomRef.once('value').then(s=>{
      if(!s.exists()){ alert("Room not found"); return; }
      const r = s.val();
      const players = r.players || [];
      if(!players.includes(username)) players.push(username);
      return roomRef.child('players').set(players);
    }).then(()=>{
      isHost = false;
      setupPresence(); // NEW: mark connected
      subscribeRoom();
      showLobby();
    });
  }

  /* ---------- LOBBY ---------- */
  function showLobby(){
    showOnly('lobbyScreen');
    byId('roomCodeDisplay').innerText = roomCode;
    const listEl = byId('playerList');

    db.ref('rooms/'+roomCode+'/players').on('value', snap=>{
      const list = snap.val() || [];
      // NEW: read connections to mark disconnected
      db.ref('rooms/'+roomCode+'/connections').once('value').then(csnap=>{
        const connMap = csnap.val()||{};
        const connected = Object.keys(connMap);
        listEl.innerHTML = list.map(p=>{
          const isConnected = connected.includes(p);
          return `<li class="${isConnected?'' : 'disconnected'}">${p}${isConnected?'' : ' (Disconnected)'}</li>`;
        }).join("");
        const canStart = isHost && list.length >= 2 && list.length <= 15;
        byId('startGameBtn').classList.toggle('hidden', !canStart);
        byId('lobbyMsg').innerText = isHost
          ? "A minimum of 2 players are needed to start, and you can have up to 15 total."
          : "Waiting for the host to start the game once everyone has joined and is ready.";
      });
    });
  }

  function startGame(){
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const players = room.players || [];
      const host = players[0];
      const others = shuffle(players.slice(1)); // randomize everyone except host
      const order = [host, ...others];
      db.ref('rooms/'+roomCode).update({ order, currentIndex: 0, state: 'wordSelect', turnStart:null });
    });
  }

  /* ---------- WORD PICK ---------- */
  function suggestWord(){
    byId('suggestedWord').innerText = phrases[Math.floor(Math.random()*phrases.length)];
  }
  function confirmWord(){
    const c = byId('customWord').value.trim();
    const w = c || byId('suggestedWord').innerText;
    if(!w) return alert("Pick or enter a word/phrase first");
    db.ref('rooms/'+roomCode).update({ word: w, state: 'drawing', currentIndex: 0, turnStart: Date.now() });
  }

  /* ---------- ROOM SUBSCRIBE / STATE MACHINE ---------- */
  let roomListenerAttached = false;
  function subscribeRoom(){
    if(roomListenerAttached) return;
    roomListenerAttached = true;

    db.ref('rooms/'+roomCode).on('value', snapshot=>{
      const room = snapshot.val();
      if(!room){ alert("Room closed"); location.reload(); return; }

      renderTurnOrder(room);
      startSharedTurnTicker(room);

      if(room.state === 'lobby'){ showLobby(); return; }

      if(room.state === 'wordSelect'){
        if(isHost) showOnly('wordSelectScreen');
        else { byId('waitMsg').innerText = "Host is choosing a word‚Ä¶"; showOnly('waitScreen'); }
        return;
      }

      const order = room.order || [];
      const idx = room.currentIndex || 0;
      const current = order[idx] || "";
      const myTurn = (current === username);

      if(room.state === 'drawing'){
        if(myTurn) startDrawingPhase(room, idx);
        else { byId('waitMsg').innerText = `${current} is drawing‚Ä¶`; showOnly('waitScreen'); }
        return;
      }

      if(room.state === 'guessing'){
        if(myTurn) startGuessingPhase(room, idx);
        else { byId('waitMsg').innerText = `${current} is guessing‚Ä¶`; showOnly('waitScreen'); }
        return;
      }

      if(room.state === 'results'){
        stopSharedTurnTicker();
        showResults(room);
        return;
      }
    });
  }

  /* ---------- SHARED TURN COUNTDOWN (Turn Order box) ---------- */
  function startSharedTurnTicker(room){
    stopSharedTurnTicker();
    updateTurnTimerLabels(room);
    turnTicker = setInterval(()=>updateTurnTimerLabels(room), 1000);
  }
  function stopSharedTurnTicker(){ if(turnTicker){ clearInterval(turnTicker); turnTicker=null; } }
  function getPhaseDuration(state){ return state==='drawing' ? 60 : state==='guessing' ? 30 : 0; }
  function computeRemaining(room){
    const ts = room.turnStart || 0;
    const dur = getPhaseDuration(room.state);
    if(!ts || !dur) return null;
    const elapsed = Math.floor((Date.now() - ts)/1000);
    return Math.max(0, dur - elapsed);
  }
  function updateTurnTimerLabels(room){
    const lists = document.querySelectorAll('.turnOrderList');
    const order = room.order || [];
    aconst = 0;
    const idx = room.currentIndex || 0;
    const remaining = computeRemaining(room);
    const connected = room.connections ? Object.keys(room.connections) : [];
    lists.forEach(list=>{
      list.innerHTML = '';
      order.forEach((name,i)=>{
        const li = document.createElement('li');
        const isConnected = connected.includes(name);
        li.textContent = (i===idx && remaining!=null) ? `${name} (${remaining}s)` : name;
        if(!isConnected){ li.classList.add('disconnected'); li.textContent += ' (Disconnected)'; }
        if(i===idx) li.classList.add('current');
        list.appendChild(li);
      });
    });
  }
  function renderTurnOrder(room){
    const boxes = document.querySelectorAll('.turnOrderBox');
    const show = (room.order || []).length > 0 && room.state !== 'lobby';
    boxes.forEach(b => b.style.display = show ? 'block' : 'none');
  }

  /* ---------- DRAWING (mobile align + undo pen-size preservation) ---------- */
  const canvas = byId('drawCanvas');
  const ctx = canvas.getContext('2d');

  function resetCanvasBackground(){
    ctx.fillStyle = "white";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }
  resetCanvasBackground();

  let drawing=false;
  let strokes=[]; // [{ size, points: [{x,y},...] }]
  let currentStroke=null;

  function highlightPen(btnId){
    ['smallPen','mediumPen','largePen'].forEach(id=>byId(id).classList.remove('activePen'));
    byId(btnId).classList.add('activePen');
  }
  function setPenSize(size){ penSize=size; highlightPen(size===2?'smallPen':size===6?'mediumPen':'largePen'); }
  setPenSize(6);

  // Scale-aware position calculation for mobile & desktop
  function getCanvasPos(e){
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width  / r.width;
    const scaleY = canvas.height / r.height;
    let clientX, clientY;

    if (e.touches && e.touches.length){
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = (e.clientX !== undefined) ? e.clientX : (e.x || 0);
      clientY = (e.clientY !== undefined) ? e.clientY : (e.y || 0);
    }

    const x = (clientX - r.left) * scaleX;
    const y = (clientY - r.top)  * scaleY;
    return { x, y };
  }

  function beginStroke(e){
    drawing = true;
    currentStroke = { size: penSize, points: [] };
    addPoint(e);
  }
  function moveStroke(e){
    if(!drawing) return;
    addPoint(e);
  }
  function endStroke(){
    if(!drawing) return;
    drawing = false;
    if(currentStroke && currentStroke.points.length){
      strokes.push(currentStroke);
    }
    currentStroke = null;
    ctx.beginPath();
  }

  function addPoint(e){
    const p = getCanvasPos(e);
    currentStroke.points.push(p);

    ctx.lineWidth = currentStroke.size; // use stroke's own size
    ctx.lineCap = "round";
    ctx.strokeStyle = "black";

    const pts = currentStroke.points;
    if(pts.length === 1){
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
    }else{
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    }
  }

  // Mouse events
  canvas.addEventListener('mousedown', beginStroke);
  canvas.addEventListener('mousemove', moveStroke);
  canvas.addEventListener('mouseup', endStroke);
  canvas.addEventListener('mouseleave', endStroke);
  // Touch events
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); beginStroke(e); }, {passive:false});
  canvas.addEventListener('touchmove',  e=>{ e.preventDefault(); moveStroke(e);  }, {passive:false});
  canvas.addEventListener('touchend',   e=>{ e.preventDefault(); endStroke();     }, {passive:false});

  function undo(){ strokes.pop(); redrawAll(); }
  function clearCanvas(){ strokes = []; ctx.clearRect(0,0,canvas.width,canvas.height); resetCanvasBackground(); }
  function redrawAll(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    resetCanvasBackground();
    for(const s of strokes){
      const pts = s.points;
      if(!pts.length) continue;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y); }
      ctx.lineWidth = s.size; ctx.strokeStyle = "black"; ctx.lineCap = "round"; ctx.stroke();
    }
  }

  function startDrawingPhase(room, idx){
    showOnly('drawingScreen');
    clearCanvas();
    setPenSize(6);
    byId('drawPrompt').innerText = (idx===0)
      ? `Draw the word/phrase: "${room.word}"`
      : `Draw this phrase: "${room.gameData[idx-1].data}"`;
    startDrawTimer(room); // pass room to sync from turnStart
  }

  // forced=false when user clicks submit; forced=true when timer expires
  function submitDrawing(forced){
    if(!forced && strokes.length===0){
      // Do NOT reset timer. Just warn; timer continues (synced by turnStart).
      alert("Please add at least one stroke before submitting.");
      return;
    }
    stopDrawTimer();
    const dataURL = canvas.toDataURL('image/png');
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const idx = room.currentIndex || 0;
      const u = {};
      u['rooms/'+roomCode+'/gameData/'+idx] = { type:'draw', data:dataURL, player:username };
      const next = idx + 1;
      if(next >= (room.order||[]).length){
        u['rooms/'+roomCode+'/state'] = 'results';
      } else {
        u['rooms/'+roomCode+'/currentIndex'] = next;
        u['rooms/'+roomCode+'/state'] = 'guessing';
        u['rooms/'+roomCode+'/turnStart'] = Date.now(); // start guess phase timer
      }
      db.ref().update(u);
    });
  }

  function startDrawTimer(room){
    stopDrawTimer(); // ensure no duplicate intervals
    const start = room.turnStart || Date.now(); // fallback for safety
    const duration = 60;
    function tick(){
      const remaining = Math.max(0, duration - Math.floor((Date.now() - start)/1000));
      byId('drawTimer').innerText = remaining + 's';
      if(remaining <= 0){ submitDrawing(true); }
    }
    tick();
    drawInterval = setInterval(tick, 1000);
  }
  function stopDrawTimer(){ if(drawInterval){ clearInterval(drawInterval); drawInterval=null; byId('drawTimer').innerText='60s'; } }

  /* ---------- GUESSING ---------- */
  function startGuessingPhase(room, idx){
    showOnly('guessScreen');
    const prev = room.gameData[idx-1];
    byId('guessImage').src = prev?.data || '';
    byId('guessInput').value = '';
    startGuessTimer(room);
  }

  function submitGuess(){
    // If empty, warn but DO NOT stop or reset timer; just let it continue
    const val = (byId('guessInput').value || '').trim();
    if(!val){
      alert("Please type a guess (or wait for the timer to auto-submit).");
      return; // keep local timer running; shared timer unaffected
    }
    stopGuessTimer();
    const g = val;
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const idx = room.currentIndex || 0;
      const u = {};
      u['rooms/'+roomCode+'/gameData/'+idx] = { type:'guess', data:g, player:username };
      const next = idx + 1;
      if(next >= (room.order||[]).length){
        u['rooms/'+roomCode+'/state'] = 'results';
      } else {
        u['rooms/'+roomCode+'/currentIndex'] = next;
        u['rooms/'+roomCode+'/state'] = 'drawing';
        u['rooms/'+roomCode+'/turnStart'] = Date.now(); // start draw phase timer
      }
      db.ref().update(u);
    });
  }

  function startGuessTimer(room){
    stopGuessTimer();
    const start = room.turnStart || Date.now();
    const duration = 30;
    function tick(){
      const remaining = Math.max(0, duration - Math.floor((Date.now() - start)/1000));
      byId('guessTimer').innerText = remaining + 's';
      if(remaining <= 0){
        // auto-submit "No guess" on timeout
        byId('guessInput').value = '';
        stopGuessTimer();
        db.ref('rooms/'+roomCode).once('value').then(s=>{
          const room = s.val();
          const idx = room.currentIndex || 0;
          const u = {};
          u['rooms/'+roomCode+'/gameData/'+idx] = { type:'guess', data:'No guess', player:username };
          const next = idx + 1;
          if(next >= (room.order||[]).length){
            u['rooms/'+roomCode+'/state'] = 'results';
          } else {
            u['rooms/'+roomCode+'/currentIndex'] = next;
            u['rooms/'+roomCode+'/state'] = 'drawing';
            u['rooms/'+roomCode+'/turnStart'] = Date.now();
          }
          db.ref().update(u);
        });
      }
    }
    tick();
    guessInterval = setInterval(tick, 1000);
  }
  function stopGuessTimer(){ if(guessInterval){ clearInterval(guessInterval); guessInterval=null; byId('guessTimer').innerText='30s'; } }

  /* ---------- RESULTS ---------- */
  function showResults(room){
    showOnly('resultsScreen');
    byId('finalWord').innerText = room.word || '';
    const list = byId('resultsList');
    list.innerHTML = '';
    const steps = Object.keys(room.gameData||{}).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
    steps.forEach(step=>{
      const e = room.gameData[step];
      const block = document.createElement('div');
      block.style.paddingTop = '12px';
      block.style.margin = '14px 0 22px 0';
      block.style.borderTop = '1px dotted #c4d9ef';
      const header = document.createElement('div');
      header.innerHTML = `<b>Step ${step+1} ‚Äî ${e.player} (${e.type})</b>`;
      block.appendChild(header);
      if(e.type === 'draw'){
        const img = document.createElement('img');
        img.src = e.data;
        img.style.maxWidth='100%';
        img.style.border='1px solid #ddd';
        img.style.borderRadius='8px';
        img.style.marginTop='8px';
        block.appendChild(img);
      } else {
        const p = document.createElement('div');
        p.textContent = e.data;
        p.style.marginTop='10px';
        block.appendChild(p);
      }
      list.appendChild(block);
    });
  }

  /* ---------- RESTART (shuffle everyone incl. host) ---------- */
  function restartGame(){
    if(!roomCode) return;
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      if(!room) return;
      const players = (room.players || []).slice();
      const newOrder = shuffle(players); // shuffle everyone, including host
      const u = {
        ['rooms/'+roomCode+'/order']: newOrder,
        ['rooms/'+roomCode+'/currentIndex']: 0,
        ['rooms/'+roomCode+'/gameData']: {},
        ['rooms/'+roomCode+'/word']: null,
        ['rooms/'+roomCode+'/state']: 'wordSelect',
        ['rooms/'+roomCode+'/turnStart']: null
      };
      return db.ref().update(u);
    });
  }
  </script>
</body>
</html>
