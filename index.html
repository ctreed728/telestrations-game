<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>üé® Telestrations Game üé®</title>
<style>
  body { font-family: Arial, sans-serif; background-color: #e6f3ff; text-align: center; margin: 0; padding: 0; color:#123; }
  h1 { color: #0b66b2; margin: 18px 0 8px; cursor:pointer; }
  .container { max-width: 900px; margin: 12px auto; background: white; padding: 18px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.08); position: relative; }
  button { background-color: #007bff; color: white; border: none; padding: 10px 14px; border-radius: 8px; cursor: pointer; }
  button:hover { background-color: #0056b3; }
  input { padding: 8px; margin: 5px; width: 80%; border-radius: 8px; border: 1px solid #cbd6e2; }
  canvas { border: 2px solid #007bff; border-radius: 10px; margin-top: 10px; background: white; touch-action: none; max-width: 100%; }
  .hidden { display: none; }
  ul { list-style: none; padding: 0; }
  .muted { color:#517089; font-size:14px; }

  /* Room code banner */
  #roomBanner { display:none; background:#d9ecff; border-top:1px solid #c4e1ff; border-bottom:1px solid #c4e1ff; padding:8px 0; font-weight:700; color:#0b66b2; }

  /* Turn order box (smaller & centered) */
  .turnOrderBox {
    display:none;
    max-width: 400px;      /* smaller than before */
    margin: 15px auto;     /* center horizontally */
    background:#f7fbff;
    border:1px solid #c4e1ff;
    border-radius:10px;
    padding:8px 10px;
    text-align:center;     /* center content */
  }
  .turnOrderBox h4 { margin:0 0 6px; color:#0b66b2; }
  .turnOrderList { padding:0; margin:0; text-align:center; }
  .turnOrderList li { list-style:none; padding:3px 0; font-size:15px; }
  .turnOrderList li.current::before { content:"‚Üí "; color:#0b66b2; font-weight:700; }

  /* Pen selection highlight */
  .activePen { background-color:#28a745 !important; }

  /* NEW: Disconnected styling */
  .disconnected { color:#9aa7b4; opacity:0.7; }

  /* Desktop tweaks */
  @media (min-width: 768px) {
    #usernameInput { width: 40%; }
    .infoPanel { width: 60%; margin: 0 auto; }
    #guessInput { width: 50%; }
  }

  /* Instruction panel */
  .infoPanel {
    margin-top: 12px; padding:10px; border-radius:10px;
    background:#eaf5ff; border:1px solid #cfe6ff; color:#0b3f6b; text-align:left;
  }
  .infoPanel h4 { margin:0 0 6px; color:#0b66b2; text-align:center; }
  .infoPanel ul { margin:0; padding-left:18px; }
  .infoPanel li { margin:4px 0; list-style: disc; }

  /* ---------------- Results visual polish ---------------- */
  #resultsList { text-align: center; } /* NEW: ensure children (including guess boxes) can center */
  .resultStepHeader {
    text-align: center;
    font-weight: bold;
    color: #0b66b2;
    margin: 20px 0 10px 0;    /* spacing above & below header */
    font-size: 1.1em;
  }
  .resultDrawing {
    display: block;
    margin: 10px auto;
    border: 2px solid #004b91; /* darker border to stand out */
    border-radius: 10px;
    background-color: #f9fbff;
    padding: 5px;
    max-width: 100%;
  }
  .resultGuess {
    display: inline-block;    /* centers via parent text-align:center */
    background-color: #f0f6ff;
    border: 1px solid #b6d4ff;
    border-radius: 10px;
    padding: 8px 14px;
    text-align: center;
    color: #123;
    margin: 12px auto;
    max-width: 90%;
    word-wrap: break-word;
  }
  .resultDivider {
    margin: 28px 0;          /* extra spacing between steps */
    border-top: 1px dotted #a3c9f7;
  }
  /* ------------------------------------------------------ */

  /* Restart box */
  #restartBox {
    margin-top: 20px; background:#eaf5ff; border:1px solid #cfe6ff; border-radius:10px;
    padding:15px; max-width:500px; margin-left:auto; margin-right:auto;
  }

  /* Mobile two-row drawing controls */
  @media (max-width: 767px) {
    #drawControlsTop, #drawControlsBottom { display:flex; justify-content:center; flex-wrap:wrap; gap:6px; }
  }
</style>
</head>
<body>
  <h1 onclick="resetToHome()">üé® Telestrations Game üé®</h1>
  <div id="roomBanner">Room Code: <span id="bannerCode"></span></div>

  <!-- HOME -->
  <div class="container" id="homeScreen">
    <h3>Enter a username:</h3>
    <input type="text" id="usernameInput" placeholder="Your username" maxlength="25"><br><br>
    <button onclick="createRoom()">Create Room</button>
    <button onclick="joinRoomPrompt()">Join Room</button>

    <div class="infoPanel">
      <h4>Here's how the game works:</h4>
      <ul>
        <li>Host creates a room and picks the first word/phrase.</li>
        <li>Turns alternate: draw (60s) ‚Üí guess (30s).</li>
        <li>Submit anytime; timer auto-submits when it ends.</li>
        <li>See the full chain at the end!</li>
      </ul>
    </div>
  </div>

  <!-- LOBBY -->
  <div class="container hidden" id="lobbyScreen">
    <h2>Room Code: <span id="roomCodeDisplay"></span></h2>
    <ul id="playerList"></ul>
    <p class="muted" id="lobbyMsg"></p>
    <button id="startGameBtn" class="hidden" onclick="startGame()">Start Game</button>

    <div class="infoPanel">
      <h4>Here's how the game works:</h4>
      <ul>
        <li>Host starts once everyone joins (2‚Äì15 players).</li>
        <li>Turns alternate: draw (60s) ‚Üí guess (30s).</li>
        <li>Submit anytime; timer auto-submits when it ends.</li>
        <li>See the full chain at the end!</li>
      </ul>
    </div>

    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- WORD SELECT -->
  <div class="container hidden" id="wordSelectScreen">
    <h3>Pick a Word or Phrase</h3>
    <input type="text" id="customWord" placeholder="Enter custom word/phrase"><br><br>
    <button onclick="suggestWord()">Suggest Word/Phrase</button> <!-- NEW: button text -->
    <p id="suggestedWord" style="font-weight:700;color:#0b66b2"></p>
    <button onclick="confirmWord()">Confirm & Start Round</button>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- DRAW -->
  <div class="container hidden" id="drawingScreen">
    <h3 id="drawPrompt"></h3>
    <div id="drawControlsTop">
      <button id="smallPen" onclick="setPenSize(2)">Small</button>
      <button id="mediumPen" onclick="setPenSize(6)">Medium</button>
      <button id="largePen" onclick="setPenSize(12)">Large</button>
    </div>
    <div id="drawControlsBottom" style="margin-top:8px;">
      <button onclick="undo()">Undo</button>
      <button onclick="clearCanvas()">Clear</button>
      <span class="timer" id="drawTimer">60s</span>
      <button onclick="submitDrawing(false)">Submit Drawing</button>
    </div>
    <canvas id="drawCanvas" width="720" height="460"></canvas>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- GUESS -->
  <div class="container hidden" id="guessScreen">
    <h3>Guess the drawing!</h3>
    <input id="guessInput" type="text" placeholder="Type your guess here" />
    <div style="margin-top:8px;">
      <span class="timer" id="guessTimer">30s</span>
      <button onclick="submitGuess()">Submit Guess</button>
    </div>
    <img id="guessImage" style="max-width:100%;border:1px solid #ddd;border-radius:8px;margin-top:10px;" />
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- WAIT -->
  <div class="container hidden" id="waitScreen">
    <p id="waitMsg">Waiting‚Ä¶</p>
    <div class="turnOrderBox"><h4>Turn Order</h4><ul class="turnOrderList"></ul></div>
  </div>

  <!-- RESULTS -->
  <div class="container hidden" id="resultsScreen">
    <h2 style="font-size:1.6em;color:#0b66b2;">Results Summary</h2>
    <div style="font-weight:700;color:#0b66b2;font-size:1.25em;">Original Word/Phrase: <span id="finalWord"></span></div>
    <div id="resultsList" style="margin-top:12px;"></div> <!-- NEW: removed text-align:left -->

    <div id="restartBox">
      <p><b>Ready for another round?</b><br>
      Restart with the same players and shuffle everyone (including the host).</p>
      <button onclick="restartGame()">üîÅ Restart Game</button>
    </div>
  </div>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
  /* ---------- FIREBASE ---------- */
  const firebaseConfig = {
    apiKey: "AIzaSyD6LY0o8SfAqX08h3tuLheGJQ9YOm1IKE0",
    authDomain: "telestrations-game-aa386.firebaseapp.com",
    databaseURL: "https://telestrations-game-aa386-default-rtdb.firebaseio.com/",
    projectId: "telestrations-game-aa386",
    storageBucket: "telestrations-game-aa386.firebasestorage.app",
    messagingSenderId: "461499249155",
    appId: "1:461499249155:web:c785ab9cd1c7aab44f1436"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  /* ---------- STATE ---------- */
  let username="", roomCode="", isHost=false, penSize=6;
  let drawInterval=null, guessInterval=null, turnTicker=null;

  /* ---------- WORD LIST (static only; odd & funny 100+) ---------- */
  const phrases = [
    "Penguin on vacation","Cactus karaoke","Wi-Fi ghost","Banana in a tuxedo","Invisible umbrella",
    "Robot doing yoga","Haunted toaster","Moonwalking giraffe","Submarine in the desert","Laptop campfire",
    "Time-traveling pizza","Squirrel traffic cop","Octopus knitting sweater","Backwards bicycle","Sneezing volcano",
    "Skateboarding elephant","Cat running a lemonade stand","Shark in a hot-air balloon","Mailbox with sunglasses","Fish walking a dog",
    "Flying carpet commute","Cow on a trampoline","Dragon roasting marshmallows","Dinosaur at the dentist","Balloons lifting a houseplant",
    "Astronaut watering plants","Camel on ice skates","Turtle with rocket boots","Unicorn stuck in traffic","Hamster paparazzi",
    "Parachuting piano","Waffle snowstorm","Hot dog reading a newspaper","Marshmallow boxing match","Bowling with coconuts",
    "Bumblebee barista","Snail delivering pizza","Kangaroo grocery shopping","Helicopter made of feathers","Toothbrush orchestra",
    "T-Rex using chopsticks","Pirate penguin","Octopus high-five line","Jellyfish lamp","Popcorn thunderstorm","Rollercoaster in a library",
    "Vampire sunscreen commercial","Mermaid on a bicycle","Yeti doing laundry","Sloth DJ","Gnome lifeguard","Cloud in a jar",
    "Couch potato literally","Dancing traffic cones","Robot babysitter","Witch on a scooter","Wizard in a hoodie","Sasquatch selfie",
    "Alien at the DMV","Zebra barcode","Pigeon mail service","Cupcake construction site","Knight walking a goldfish",
    "Koala astronaut","Llama hair salon","Narwhal birthday party","Cheese moon landing","Ice cream in a sauna",
    "Ghost stuck in revolving door","Spider web hammock","Mismatched socks parade","Accordion snake","Broomstick car wash",
    "Bubble wrap runway","Cereal bowl swimming pool","Tornado in a teacup","Fire-breathing squirrel","Gorilla tea party",
    "Compass that only points up","Map that‚Äôs scribbles","Invisible dog leash","Mailbox eating letters","Mirror with stage fright",
    "Popsicle sunset","Penguin lifeguard","Cactus snowman","Skunk perfume tester","Toaster spaceship","Cloud mowing the lawn",
    "Dolphin on a pogo stick","Watering can rainstorm","Pizza delivery by drone dragon","Kite surfing in a bathtub","Suitcase with feelings",
    "Coffee mug telescope","Microwave time machine","Sneakers made of clouds","Bicycle with square wheels","Trombone tornado",
    "Robot choir","Sandcastle skyscraper","Glasses on a statue blinking","Train made of spaghetti","Raincoat for a cat",
    "Bubblegum galaxy","Hedgehog barbershop","Avocado karate","Haunted sock","Candle doing taxes",
    "Pumpkin scuba diver","Mailbox karaoke","Ladder to the moon","Coconut laptop","Cranes lifting a rainbow",
    "Thunderstorm with confetti","Paper airplane airline","Donut eclipse","Cucumber cowboy","Piano under the sea",
    "Taco telescope","Penguin orchestra","Squirrel yoga class","Skateboard made of books","Basketball on the moon",
    "Koala hot air balloon","Ice cube in the desert","Raccoon pizza chef","Origami dragonfly","Marshmallow camp counselor",
    "Potato astronaut","Dragon reading bedtime stories","Rubber duck safari","Waffle iron orchestra","Penguin snowplow",
    "Caterpillar limousine","Spaghetti jump rope","Snowman with a sunburn","Tooth fairy stuck in traffic","Cup of tea surfing",
    "Elevator to nowhere","Moon cheese factory","Robot gardening in space","Umbrella playing poker","Pillow fight tournament"
  ];

  /* ---------- UTIL ---------- */
  const byId = id => document.getElementById(id);
  function showOnly(id){
    ["homeScreen","lobbyScreen","wordSelectScreen","drawingScreen","guessScreen","waitScreen","resultsScreen"]
      .forEach(el=>byId(el).classList.add("hidden"));
    byId(id).classList.remove("hidden");
  }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
  function setBanner(code){ byId('bannerCode').textContent = code; byId('roomBanner').style.display='block'; }
  function resetToHome(){ location.reload(); }

  /* ---------- NEW: PRESENCE (mark connected clients & auto-remove on disconnect) ---------- */
  function setupPresence(){
    if(!roomCode || !username) return;
    const connRef = db.ref(`rooms/${roomCode}/connections/${username}`);
    connRef.set(true);
    connRef.onDisconnect().remove();
  }

  /* ---------- CREATE / JOIN ---------- */
  function createRoom(){
    username = byId('usernameInput').value.trim();
    if(!username) return alert("Enter a username first");
    isHost = true;
    roomCode = Math.random().toString(36).substring(2,6).toUpperCase();
    setBanner(roomCode);

    /* ---------- CLEANUP: delete any rooms 24h+ old before creating a new one ---------- */
    const now = Date.now();
    const roomsRef = db.ref('rooms');
    roomsRef.once('value').then(snapshot=>{
      snapshot.forEach(roomSnap=>{
        const room = roomSnap.val();
        if (room && room.createdAt && (now - room.createdAt > 24*60*60*1000)) {
          roomSnap.ref.remove();
        }
      });
    }).then(()=>{
      /* ---------- create the room (note createdAt) ---------- */
      return db.ref('rooms/'+roomCode).set({
        host: username, players: [username], state:'lobby',
        createdAt: now, // NEW: timestamp for cleanup checks
        order: null, currentIndex: 0, gameData:{}, word:null, turnStart:null,
        connections: {} // NEW: presence map
      });
    }).then(()=>{
      setupPresence();
      subscribeRoom();
      showLobby();
    });
  }

  function joinRoomPrompt(){
    username = byId('usernameInput').value.trim();
    if(!username) return alert("Enter a username first");
    const code = prompt("Enter Room Code (not case-sensitive):");
    if(!code) return;
    roomCode = code.toUpperCase();
    setBanner(roomCode);

    const roomRef = db.ref('rooms/'+roomCode);
    roomRef.once('value').then(s=>{
      if(!s.exists()){ alert("Room not found"); return; }
      const r = s.val();

      // (Optional safeguard) If a room somehow lived beyond 24h and wasn't purged yet:
      const now = Date.now();
      if (r.createdAt && (now - r.createdAt > 24*60*60*1000)) {
        alert("This room has expired and will be deleted. Please create a new one.");
        roomRef.remove();
        return;
      }

      const players = r.players || [];
      if(!players.includes(username)) players.push(username);

      // üîπ FIX: Wait for .set() to finish before continuing (prevents join race + false disconnect flicker)
      return roomRef.child('players').set(players).then(() => {
        isHost = false;
        setupPresence();   // register connection AFTER player list is saved
        subscribeRoom();   // start listeners
        showLobby();       // show lobby on the joiner‚Äôs client
      });
    });
  }

  /* ---------- LOBBY ---------- */
  function showLobby(){
    showOnly('lobbyScreen');
    byId('roomCodeDisplay').innerText = roomCode;
    const listEl = byId('playerList');

    db.ref('rooms/'+roomCode+'/players').on('value', snap=>{
      const list = snap.val() || [];
      // NEW: read connections to mark disconnected
      db.ref('rooms/'+roomCode+'/connections').once('value').then(csnap=>{
        const connMap = csnap.val()||{};
        const connected = Object.keys(connMap);
        listEl.innerHTML = list.map(p=>{
          const isConnected = connected.includes(p);
          return `<li class="${isConnected?'' : 'disconnected'}">${p}${isConnected?'' : ' (Disconnected)'}</li>`;
        }).join("");
        const canStart = isHost && list.length >= 2 && list.length <= 15;
        byId('startGameBtn').classList.toggle('hidden', !canStart);
        byId('lobbyMsg').innerText = isHost
          ? "A minimum of 2 players are needed to start, and you can have up to 15 total."
          : "Waiting for the host to start the game once everyone has joined and is ready.";
      });
    });
  }

  function startGame(){
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const players = room.players || [];
      const host = players[0];
      const others = shuffle(players.slice(1)); // randomize everyone except host
      const order = [host, ...others];
      db.ref('rooms/'+roomCode).update({ order, currentIndex: 0, state: 'wordSelect', turnStart:null });
    });
  }

  /* ---------- WORD PICK ---------- */
  // NEW: Static-only suggestion (API removed)
  function suggestWord(){
    byId('suggestedWord').innerText = phrases[Math.floor(Math.random()*phrases.length)];
  }

  function confirmWord(){
    const c = byId('customWord').value.trim();
    const w = c || byId('suggestedWord').innerText;
    if(!w) return alert("Pick or enter a word/phrase first");
    db.ref('rooms/'+roomCode).update({ word: w, state: 'drawing', currentIndex: 0, turnStart: Date.now() });
  }

  /* ---------- ROOM SUBSCRIBE / STATE MACHINE ---------- */
  let roomListenerAttached = false;
  function subscribeRoom(){
    if(roomListenerAttached) return;
    roomListenerAttached = true;

    db.ref('rooms/'+roomCode).on('value', snapshot=>{
      const room = snapshot.val();
      if(!room){ alert("Room closed"); location.reload(); return; }

      renderTurnOrder(room);
      startSharedTurnTicker(room);

      if(room.state === 'lobby'){ showLobby(); return; }

      // FIX: word selection always belongs to the first player in current order (persists across restarts)
      if(room.state === 'wordSelect'){
        const firstPlayer = room.order && room.order.length ? room.order[0] : room.host;
        if(username === firstPlayer){
          showOnly('wordSelectScreen');
        } else {
          byId('waitMsg').innerText = `${firstPlayer} is choosing a word‚Ä¶`;
          showOnly('waitScreen');
        }
        return;
      }

      const order = room.order || [];
      const idx = room.currentIndex || 0;
      const current = order[idx] || "";
      const myTurn = (current === username);

      if(room.state === 'drawing'){
        if(myTurn) startDrawingPhase(room, idx);
        else { byId('waitMsg').innerText = `${current} is drawing‚Ä¶`; showOnly('waitScreen'); }
        return;
      }

      if(room.state === 'guessing'){
        if(myTurn) startGuessingPhase(room, idx);
        else { byId('waitMsg').innerText = `${current} is guessing‚Ä¶`; showOnly('waitScreen'); }
        return;
      }

      if(room.state === 'results'){
        stopSharedTurnTicker();
        showResults(room);
        return;
      }
    });
  }

  /* ---------- SHARED TURN COUNTDOWN (Turn Order box) ---------- */
  function startSharedTurnTicker(room){
    stopSharedTurnTicker();
    updateTurnTimerLabels(room);
    turnTicker = setInterval(()=>updateTurnTimerLabels(room), 1000);
  }
  function stopSharedTurnTicker(){ if(turnTicker){ clearInterval(turnTicker); turnTicker=null; } }
  function getPhaseDuration(state){ return state==='drawing' ? 60 : state==='guessing' ? 30 : 0; }
  function computeRemaining(room){
    const ts = room.turnStart || 0;
    const dur = getPhaseDuration(room.state);
    if(!ts || !dur) return null;
    const elapsed = Math.floor((Date.now() - ts)/1000);
    return Math.max(0, dur - elapsed);
  }
  function updateTurnTimerLabels(room){
    const lists = document.querySelectorAll('.turnOrderList');
    const order = room.order || [];
    const idx = room.currentIndex || 0;
    const remaining = computeRemaining(room);
    const connected = room.connections ? Object.keys(room.connections) : [];
    lists.forEach(list=>{
      list.innerHTML = '';
      order.forEach((name,i)=>{
        const li = document.createElement('li');
        const isConnected = connected.includes(name);
        li.textContent = (i===idx && remaining!=null) ? `${name} (${remaining}s)` : name;
        if(!isConnected){ li.classList.add('disconnected'); li.textContent += ' (Disconnected)'; }
        if(i===idx) li.classList.add('current');
        list.appendChild(li);
      });
    });
  }
  function renderTurnOrder(room){
    const boxes = document.querySelectorAll('.turnOrderBox');
    const show = (room.order || []).length > 0 && room.state !== 'lobby';
    boxes.forEach(b => b.style.display = show ? 'block' : 'none');
  }

  /* ---------- DRAWING (mobile align + undo pen-size preservation) ---------- */
  const canvas = byId('drawCanvas');
  const ctx = canvas.getContext('2d');

  function resetCanvasBackground(){
    ctx.fillStyle = "white";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }
  resetCanvasBackground();

  let drawing=false;
  let strokes=[]; // [{ size, points: [{x,y},...] }]
  let currentStroke=null;

  function highlightPen(btnId){
    ['smallPen','mediumPen','largePen'].forEach(id=>byId(id).classList.remove('activePen'));
    byId(btnId).classList.add('activePen');
  }
  function setPenSize(size){ penSize=size; highlightPen(size===2?'smallPen':size===6?'mediumPen':'largePen'); }
  setPenSize(6);

  // Scale-aware position calculation for mobile & desktop
  function getCanvasPos(e){
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width  / r.width;
    const scaleY = canvas.height / r.height;
    let clientX, clientY;

    if (e.touches && e.touches.length){
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = (e.clientX !== undefined) ? e.clientX : (e.x || 0);
      clientY = (e.clientY !== undefined) ? e.clientY : (e.y || 0);
    }

    const x = (clientX - r.left) * scaleX;
    const y = (clientY - r.top)  * scaleY;
    return { x, y };
  }

  function beginStroke(e){
    drawing = true;
    currentStroke = { size: penSize, points: [] };
    addPoint(e);
  }
  function moveStroke(e){
    if(!drawing) return;
    addPoint(e);
  }
  function endStroke(){
    if(!drawing) return;
    drawing = false;
    if(currentStroke && currentStroke.points.length){
      strokes.push(currentStroke);
    }
    currentStroke = null;
    ctx.beginPath();
  }

  function addPoint(e){
    const p = getCanvasPos(e);
    currentStroke.points.push(p);

    ctx.lineWidth = currentStroke.size; // use stroke's own size
    ctx.lineCap = "round";
    ctx.strokeStyle = "black";

    const pts = currentStroke.points;
    if(pts.length === 1){
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
    }else{
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    }
  }

  // Mouse events
  canvas.addEventListener('mousedown', beginStroke);
  canvas.addEventListener('mousemove', moveStroke);
  canvas.addEventListener('mouseup', endStroke);
  canvas.addEventListener('mouseleave', endStroke);
  // Touch events
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); beginStroke(e); }, {passive:false});
  canvas.addEventListener('touchmove',  e=>{ e.preventDefault(); moveStroke(e);  }, {passive:false});
  canvas.addEventListener('touchend',   e=>{ e.preventDefault(); endStroke();     }, {passive:false});

  function undo(){ strokes.pop(); redrawAll(); }
  function clearCanvas(){ strokes = []; ctx.clearRect(0,0,canvas.width,canvas.height); resetCanvasBackground(); }
  function redrawAll(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    resetCanvasBackground();
    for(const s of strokes){
      const pts = s.points;
      if(!pts.length) continue;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y); }
      ctx.lineWidth = s.size; ctx.strokeStyle = "black"; ctx.lineCap = "round"; ctx.stroke();
    }
  }

  function startDrawingPhase(room, idx){
    showOnly('drawingScreen');
    clearCanvas();
    setPenSize(6);
    byId('drawPrompt').innerText = (idx===0)
      ? `Draw the word/phrase: "${room.word}"`
      : `Draw this phrase: "${room.gameData[idx-1].data}"`;
    startDrawTimer(room); // pass room to sync from turnStart
  }

  // forced=false when user clicks submit; forced=true when timer expires
  function submitDrawing(forced){
    if(!forced && strokes.length===0){
      // Do NOT reset timer. Just warn; timer continues (synced by turnStart).
      alert("Please add at least one stroke before submitting.");
      return;
    }
    stopDrawTimer();
    const dataURL = canvas.toDataURL('image/png');
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const idx = room.currentIndex || 0;
      const u = {};
      u['rooms/'+roomCode+'/gameData/'+idx] = { type:'draw', data:dataURL, player:username };
      const next = idx + 1;
      if(next >= (room.order||[]).length){
        u['rooms/'+roomCode+'/state'] = 'results';
      } else {
        u['rooms/'+roomCode+'/currentIndex'] = next;
        u['rooms/'+roomCode+'/state'] = 'guessing';
        u['rooms/'+roomCode+'/turnStart'] = Date.now(); // start guess phase timer
      }
      db.ref().update(u);
    });
  }

  function startDrawTimer(room){
    stopDrawTimer(); // ensure no duplicate intervals
    const start = room.turnStart || Date.now(); // fallback for safety
    const duration = 60;
    function tick(){
      const remaining = Math.max(0, duration - Math.floor((Date.now() - start)/1000));
      byId('drawTimer').innerText = remaining + 's';
      if(remaining <= 0){ submitDrawing(true); }
    }
    tick();
    drawInterval = setInterval(tick, 1000);
  }
  function stopDrawTimer(){ if(drawInterval){ clearInterval(drawInterval); drawInterval=null; byId('drawTimer').innerText='60s'; } }

  /* ---------- GUESSING ---------- */
  function startGuessingPhase(room, idx){
    showOnly('guessScreen');
    const prev = room.gameData[idx-1];
    byId('guessImage').src = prev?.data || '';
    byId('guessInput').value = '';
    startGuessTimer(room);
  }

  function submitGuess(){
    // If empty, warn but DO NOT stop or reset timer; just let it continue
    const val = (byId('guessInput').value || '').trim();
    if(!val){
      alert("Please type a guess (or wait for the timer to auto-submit).");
      return; // keep local timer running; shared timer unaffected
    }
    stopGuessTimer();
    const g = val;
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      const idx = room.currentIndex || 0;
      const u = {};
      u['rooms/'+roomCode+'/gameData/'+idx] = { type:'guess', data:g, player:username };
      const next = idx + 1;
      if(next >= (room.order||[]).length){
        u['rooms/'+roomCode+'/state'] = 'results';
      } else {
        u['rooms/'+roomCode+'/currentIndex'] = next;
        u['rooms/'+roomCode+'/state'] = 'drawing';
        u['rooms/'+roomCode+'/turnStart'] = Date.now(); // start draw phase timer
      }
      db.ref().update(u);
    });
  }

  function startGuessTimer(room){
    stopGuessTimer();
    const start = room.turnStart || Date.now();
    const duration = 30;
    function tick(){
      const remaining = Math.max(0, duration - Math.floor((Date.now() - start)/1000));
      byId('guessTimer').innerText = remaining + 's';
      if(remaining <= 0){
        // auto-submit "No guess" on timeout
        byId('guessInput').value = '';
        stopGuessTimer();
        db.ref('rooms/'+roomCode).once('value').then(s=>{
          const room = s.val();
          const idx = room.currentIndex || 0;
          const u = {};
          u['rooms/'+roomCode+'/gameData/'+idx] = { type:'guess', data:'No guess', player:username };
          const next = idx + 1;
          if(next >= (room.order||[]).length){
            u['rooms/'+roomCode+'/state'] = 'results';
          } else {
            u['rooms/'+roomCode+'/currentIndex'] = next;
            u['rooms/'+roomCode+'/state'] = 'drawing';
            u['rooms/'+roomCode+'/turnStart'] = Date.now();
          }
          db.ref().update(u);
        });
      }
    }
    tick();
    guessInterval = setInterval(tick, 1000);
  }
  function stopGuessTimer(){ if(guessInterval){ clearInterval(guessInterval); guessInterval=null; byId('guessTimer').innerText='30s'; } }

  /* ---------- RESULTS ---------- */
  function showResults(room){
    showOnly('resultsScreen');
    byId('finalWord').innerText = room.word || '';
    const list = byId('resultsList');
    list.innerHTML = '';
    const steps = Object.keys(room.gameData||{}).map(n=>parseInt(n,10)).sort((a,b)=>a-b);

    steps.forEach(step=>{
      const e = room.gameData[step];
      const block = document.createElement('div');

      // Centered, bold header (Step N ‚Äî player (type))
      const header = document.createElement('div');
      header.classList.add('resultStepHeader');
      header.innerText = `Step ${step+1} ‚Äî ${e.player} (${e.type})`;
      block.appendChild(header);

      if(e.type === 'draw'){
        // Centered image with darker border + padding
        const img = document.createElement('img');
        img.src = e.data;
        img.classList.add('resultDrawing');
        block.appendChild(img);
      } else {
        // Centered, boxed guess (parent #resultsList now centers children)
        const guessBox = document.createElement('div');
        guessBox.classList.add('resultGuess');
        guessBox.innerText = e.data;
        block.appendChild(guessBox);
      }

      // Extra-spaced dotted divider between steps
      const divider = document.createElement('div');
      divider.classList.add('resultDivider');
      block.appendChild(divider);

      list.appendChild(block);
    });
  }

  /* ---------- RESTART (shuffle everyone incl. host) ---------- */
  function restartGame(){
    if(!roomCode) return;
    db.ref('rooms/'+roomCode).once('value').then(s=>{
      const room = s.val();
      if(!room) return;
      const players = (room.players || []).slice();
      const newOrder = shuffle(players); // shuffle everyone, including host
      const u = {
        ['rooms/'+roomCode+'/order']: newOrder,
        ['rooms/'+roomCode+'/currentIndex']: 0,
        ['rooms/'+roomCode+'/gameData']: {},
        ['rooms/'+roomCode+'/word']: null,
        ['rooms/'+roomCode+'/state']: 'wordSelect',
        ['rooms/'+roomCode+'/turnStart']: null
      };
      return db.ref().update(u);
    });
  }
  </script>
</body>
</html>
