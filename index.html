<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ðŸŽ¨ Telestrations Multiplayer (Fixed)</title>
<style>
  body { font-family: Arial, sans-serif; background-color: #e6f3ff; text-align: center; margin: 0; padding: 0; }
  h1 { color: #333; margin: 20px 0; }
  .container { max-width: 700px; margin: 20px auto; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
  button { background-color: #007bff; color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; }
  button:hover { background-color: #0056b3; }
  input { padding: 8px; margin: 5px; width: 80%; border-radius: 8px; border: 1px solid #ccc; }
  canvas { border: 2px solid #007bff; border-radius: 10px; margin-top: 10px; background: white; touch-action: none; max-width: 100%; }
  .hidden { display: none; }
  ul { list-style: none; padding: 0; }
  #waitMsg { font-weight: 700; color: #333; }
  .timer { font-weight: 800; color: #0b66b2; }
</style>
</head>
<body>
<h1>ðŸŽ¨ Telestrations Multiplayer (Fixed)</h1>

<!-- HOME -->
<div class="container" id="homeScreen">
  <h3>Enter your name:</h3>
  <input type="text" id="usernameInput" placeholder="Your name"><br><br>
  <button onclick="createRoom()">Create Room</button>
  <button onclick="joinRoomPrompt()">Join Room</button>
</div>

<!-- LOBBY -->
<div class="container hidden" id="lobbyScreen">
  <h2>Room Code: <span id="roomCodeDisplay"></span></h2>
  <p>Players Joined:</p>
  <ul id="playerList"></ul>
  <button id="startGameBtn" class="hidden" onclick="startGame()">Start Game</button>
</div>

<!-- WORD PICK (host only) -->
<div class="container hidden" id="wordSelectScreen">
  <h3>Pick a Word or Phrase</h3>
  <input type="text" id="customWord" placeholder="Enter custom word/phrase"><br><br>
  <button onclick="suggestWord()">Suggest Word</button>
  <p id="suggestedWord" style="font-weight:700;color:#0b66b2"></p>
  <button onclick="confirmWord()">Confirm & Start Round</button>
</div>

<!-- DRAW TURN -->
<div class="container hidden" id="drawingScreen">
  <h3 id="drawPrompt"></h3>
  <canvas id="drawCanvas" width="640" height="420"></canvas><br>
  <div>
    <button onclick="setPenSize(2)">Small</button>
    <button onclick="setPenSize(6)">Medium</button>
    <button onclick="setPenSize(12)">Large</button>
  </div>
  <div style="margin-top:8px;">
    <button onclick="undo()">Undo</button>
    <button onclick="clearCanvas()">Clear</button>
    <span style="margin:0 8px;" class="timer" id="drawTimer">60s</span>
    <button onclick="submitDrawing()">Submit Drawing</button>
  </div>
</div>

<!-- GUESS TURN -->
<div class="container hidden" id="guessScreen">
  <h3>Guess the drawing!</h3>
  <img id="guessImage" style="max-width:100%;border:1px solid #ddd;border-radius:8px" />
  <div style="margin-top:10px;">
    <input id="guessInput" type="text" placeholder="Type your guess here" />
  </div>
  <div style="margin-top:8px;">
    <span class="timer" id="guessTimer">30s</span>
    <button onclick="submitGuess()">Submit Guess</button>
  </div>
</div>

<!-- WAITING VIEW -->
<div class="container hidden" id="waitScreen">
  <p id="waitMsg">Waitingâ€¦</p>
</div>

<!-- RESULTS -->
<div class="container hidden" id="resultsScreen">
  <h2>Results Summary</h2>
  <div style="font-weight:700;color:#0b66b2">Original: <span id="finalWord"></span></div>
  <div id="resultsList" style="text-align:left;margin-top:12px;"></div>
</div>

<!-- Firebase compat (works on GitHub Pages) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

<script>
/* ---------- FIREBASE ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyD6LY0o8SfAqX08h3tuLheGJQ9YOm1IKE0",
  authDomain: "telestrations-game-aa386.firebaseapp.com",
  databaseURL: "https://telestrations-game-aa386-default-rtdb.firebaseio.com/",
  projectId: "telestrations-game-aa386",
  storageBucket: "telestrations-game-aa386.firebasestorage.app",
  messagingSenderId: "461499249155",
  appId: "1:461499249155:web:c785ab9cd1c7aab44f1436"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------- STATE ---------- */
let username = "";
let roomCode = "";
let isHost = false;
let penSize = 6;

let drawInterval = null;
let guessInterval = null;

/* ---------- WORD LIST ---------- */
const phrases = [
  "Awkward handshake","Breakfast in bed","Lost astronaut","Surfing grandma","Invisible dog",
  "Juggling flamingos","Couch potato","Dancing with wolves","Robot yoga","Time capsule",
  "Elephant on a skateboard","Synchronized napping","Haunted smartphone","Midnight snack attack",
  "Window-shopping dinosaur","Broken umbrella parade","Flying carpet commute","Secret admirer note",
  "Backwards clock","Talking mailbox","Cat's out of the bag","Under the weather",
  "Hot potato","Piece of cake","Fish out of water","Treasure map","Giraffe on roller skates",
  "Walking on eggshells","Tickled pink","Belly flop contest","Too many cooks","Lost in translation",
  "Treasure chest","Barking up the wrong tree","Two peas in a pod","Dancing queen","Rocket-powered shoes"
];

/* ---------- UI HELPERS ---------- */
const byId = id => document.getElementById(id);
function showOnly(id) {
  ["homeScreen","lobbyScreen","wordSelectScreen","drawingScreen","guessScreen","waitScreen","resultsScreen"]
    .forEach(el => byId(el).classList.add("hidden"));
  byId(id).classList.remove("hidden");
}
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }

/* ---------- ROOM FLOW ---------- */
function createRoom() {
  username = byId('usernameInput').value.trim();
  if (!username) return alert("Please enter your name");
  isHost = true;
  roomCode = Math.random().toString(36).substring(2, 6).toUpperCase();

  const roomObj = {
    host: username,
    players: [username],
    state: 'lobby',
    order: null,
    currentIndex: 0,
    gameData: {},
    word: null
  };
  db.ref('rooms/' + roomCode).set(roomObj);
  subscribeRoom();
  showLobby();
}

function joinRoomPrompt() {
  username = byId('usernameInput').value.trim();
  if (!username) return alert("Please enter your name");
  const code = (prompt("Enter Room Code:") || "").toUpperCase();
  if (!code) return;
  roomCode = code;

  const playerRef = db.ref('rooms/' + roomCode + '/players');
  playerRef.transaction(list => {
    list = list || [];
    if (!list.includes(username)) list.push(username);
    return list;
  }, (err, committed, snap) => {
    if (err || !committed || !snap.exists()) { alert("Room not found or join failed."); return; }
    isHost = false;
    subscribeRoom();
    showLobby();
  });
}

function showLobby() {
  showOnly('lobbyScreen');
  byId('roomCodeDisplay').innerText = roomCode;
  const listEl = byId('playerList');
  db.ref('rooms/' + roomCode + '/players').on('value', snapshot => {
    const list = snapshot.val() || [];
    listEl.innerHTML = list.map(p => `<li>${p}</li>`).join("");
    const canStart = isHost && list.length >= 2 && list.length <= 12;
    byId('startGameBtn').classList.toggle('hidden', !canStart);
  });
}

function startGame() {
  db.ref('rooms/' + roomCode).once('value').then(snap => {
    const room = snap.val();
    const players = room.players || [];
    const host = players[0];
    const others = shuffle(players.slice(1));
    const order = [host, ...others];
    db.ref('rooms/' + roomCode).update({
      order, currentIndex: 0, state: 'wordSelect'
    });
  });
}

function suggestWord() {
  const w = phrases[Math.floor(Math.random() * phrases.length)];
  byId('suggestedWord').innerText = w;
}

function confirmWord() {
  const custom = byId('customWord').value.trim();
  const word = custom || byId('suggestedWord').innerText;
  if (!word) return alert("Pick or enter a word/phrase first");
  db.ref('rooms/' + roomCode).update({ word, state: 'drawing', currentIndex: 0 });
}

/* ---------- SUBSCRIBE TO ROOM CHANGES ---------- */
let roomListenerAttached = false;
function subscribeRoom(){
  if (roomListenerAttached) return;
  roomListenerAttached = true;

  db.ref('rooms/' + roomCode).on('value', snapshot => {
    const room = snapshot.val();
    if (!room) { alert("Room closed"); location.reload(); return; }

    if (room.state === 'lobby') return showLobby();

    if (room.state === 'wordSelect') {
      if (isHost) showOnly('wordSelectScreen');
      else { byId('waitMsg').innerText = "Host is choosing a wordâ€¦"; showOnly('waitScreen'); }
      return;
    }

    if (room.state === 'drawing' || room.state === 'guessing') {
      const order = room.order || [];
      const idx = room.currentIndex || 0;
      const currentPlayer = order[idx] || "";
      const isMyTurn = (currentPlayer === username);
      stopDrawTimer(); stopGuessTimer();

      if (room.state === 'drawing') {
        if (isMyTurn) startDrawingPhase(room, idx);
        else { byId('waitMsg').innerText = `${currentPlayer} is drawingâ€¦`; showOnly('waitScreen'); }
      } else {
        if (isMyTurn) startGuessingPhase(room, idx);
        else { byId('waitMsg').innerText = `${currentPlayer} is guessingâ€¦`; showOnly('waitScreen'); }
      }
      return;
    }

    if (room.state === 'results') return showResults(room);
  });
}

/* ---------- DRAWING ---------- */
const canvas = byId('drawCanvas');
const ctx = canvas.getContext('2d');
function resetCanvasBackground() {
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}
resetCanvasBackground();

let drawing = false;
let strokes = [];
let currentStroke = [];

function setPenSize(size){ penSize = size; }
function getPos(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.offsetX !== undefined) ? e.offsetX : (e.touches ? e.touches[0].clientX - rect.left : 0);
  const y = (e.offsetY !== undefined) ? e.offsetY : (e.touches ? e.touches[0].clientY - rect.top : 0);
  return {x, y};
}
function beginStroke(e){ drawing = true; currentStroke = []; addPoint(e); }
function moveStroke(e){ if(!drawing) return; addPoint(e); }
function endStroke(){ if(!drawing) return; drawing = false; if(currentStroke.length) strokes.push(currentStroke); ctx.beginPath(); }

function addPoint(e){
  const p = getPos(e);
  currentStroke.push(p);
  ctx.lineWidth = penSize;
  ctx.lineCap = "round";
  ctx.strokeStyle = "black";
  if (currentStroke.length === 1) { ctx.beginPath(); ctx.moveTo(p.x,p.y); }
  else { ctx.lineTo(p.x,p.y); ctx.stroke(); }
}
canvas.addEventListener('mousedown', beginStroke);
canvas.addEventListener('mousemove', moveStroke);
canvas.addEventListener('mouseup', endStroke);
canvas.addEventListener('mouseleave', endStroke);
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); beginStroke(e); }, {passive:false});
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); moveStroke(e); }, {passive:false});
canvas.addEventListener('touchend', e=>{ e.preventDefault(); endStroke(); }, {passive:false});

function undo(){ strokes.pop(); redrawAll(); }
function clearCanvas(){ strokes = []; ctx.clearRect(0,0,canvas.width,canvas.height); resetCanvasBackground(); }
function redrawAll(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  resetCanvasBackground();
  for (const s of strokes) {
    ctx.beginPath();
    s.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
    ctx.lineWidth = penSize;
    ctx.strokeStyle = "black";
    ctx.stroke();
  }
}

function startDrawingPhase(room, idx){
  showOnly('drawingScreen');
  strokes = [];
  ctx.clearRect(0,0,canvas.width,canvas.height);
  resetCanvasBackground();
  const first = (idx === 0);
  byId('drawPrompt').innerText = first
    ? `Draw the word/phrase: "${room.word}"`
    : `Draw this phrase: "${(room.gameData && room.gameData[idx-1] && room.gameData[idx-1].data) || ""}"`;
  startDrawTimer();
}

function submitDrawing(){
  stopDrawTimer();
  const dataURL = canvas.toDataURL('image/png');
  db.ref('rooms/' + roomCode).once('value').then(snap=>{
    const room = snap.val();
    const idx = room.currentIndex || 0;
    const updates = {};
    updates['rooms/'+roomCode+'/gameData/'+idx] = { type:'draw', data:dataURL, player:username };
    const nextIdx = idx + 1;
    if (nextIdx >= (room.order || []).length) updates['rooms/'+roomCode+'/state'] = 'results';
    else { updates['rooms/'+roomCode+'/currentIndex'] = nextIdx; updates['rooms/'+roomCode+'/state'] = 'guessing'; }
    db.ref().update(updates);
  });
}

function startDrawTimer(){
  let t = 60;
  byId('drawTimer').innerText = t + 's';
  drawInterval = setInterval(()=>{
    t--; byId('drawTimer').innerText = t + 's';
    if (t <= 0) submitDrawing();
  },1000);
}
function stopDrawTimer(){ if(drawInterval){ clearInterval(drawInterval); drawInterval=null; byId('drawTimer').innerText='60s'; } }

/* ---------- GUESSING ---------- */
function startGuessingPhase(room, idx){
  showOnly('guessScreen');
  const prev = room.gameData && room.gameData[idx-1];
  byId('guessImage').src = (prev && prev.type==='draw') ? prev.data : '';
  byId('guessInput').value = '';
  startGuessTimer();
}

function submitGuess(){
  stopGuessTimer();
  const guess = (byId('guessInput').value || '').trim() || 'No guess';
  db.ref('rooms/' + roomCode).once('value').then(snap=>{
    const room = snap.val();
    const idx = room.currentIndex || 0;
    const updates = {};
    updates['rooms/'+roomCode+'/gameData/'+idx] = { type:'guess', data:guess, player:username };
    const nextIdx = idx + 1;
    if (nextIdx >= (room.order || []).length) updates['rooms/'+roomCode+'/state'] = 'results';
    else { updates['rooms/'+roomCode+'/currentIndex'] = nextIdx; updates['rooms/'+roomCode+'/state'] = 'drawing'; }
    db.ref().update(updates);
  });
}

function startGuessTimer(){
  let t = 30;
  byId('guessTimer').innerText = t + 's';
  guessInterval = setInterval(()=>{
    t--; byId('guessTimer').innerText = t + 's';
    if (t <= 0) submitGuess();
  },1000);
}
function stopGuessTimer(){ if(guessInterval){ clearInterval(guessInterval); guessInterval=null; byId('guessTimer').innerText='30s'; } }

/* ---------- RESULTS ---------- */
function showResults(room){
  showOnly('resultsScreen');
  byId('finalWord').innerText = room.word || '';
  const list = byId('resultsList');
  list.innerHTML = '';
  const steps = Object.keys(room.gameData||{}).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
  stepsâ€¦and the rest of that file continues exactly as in your previous working version (no logic changed beyond the canvas).  

âœ… **Summary of whatâ€™s new:**
- Removed `{alpha:false}` from the canvas context.
- Added a helper `resetCanvasBackground()` to always fill it white.
- That function runs when the game starts drawing **and** when the canvas is cleared.

That will stop the black background from appearing â€” your drawing area will now always start clean white, consistent across browsers and devices.  

Once you paste and republish this, youâ€™ll be able to verify it by starting a new round: the drawing panel should show a white canvas ready for use.
